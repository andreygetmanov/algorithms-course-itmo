# -*- coding: utf-8 -*-
"""Lab1. Time Complexity.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ybm-M9xVjtB2LtMmR0WNmtE2t4So_K-z

const - O(1)

sum - O(n)

prod - O(n)

naivepoly - O(n^2)

hornerpoly - O(n)

bubble - O(n^2)

quick - O(nlogn)

tim - O(nlogn)

matrix - O(n^3)
"""

import numpy as np
import math
import time
import matplotlib.pyplot as plt
import timeit
from tqdm import tqdm

"""#Functions"""

def const(n):
  return 5

def summa(v):
  sum = 0
  for i in range(len(v)):
    sum += v[i]
  return sum

def prod(v):
  prod = 1
  for i in range(len(v)):
    prod *= v[i]
  return prod

def Horner(c,x):
    p=0
    for i in c[-1::-1]:
        p = p * x + i
    return p

def naive(c,x):
    n = len(c)
    p = 0
    for i in range(len(c)):
        p += c[i] * power(x, i) 
    return p

def power(a,n):
	if a == 0:
		return 0
	if n < 0:
		a = 1.0 / a
		n = -n
	res = 1
	while n > 0:
		res = res * a
		n = n - 1
	return res

def bubbleSort(arr):
    n = len(arr)
 
    # Traverse through all array elements
    for i in range(n-1):
    # range(n) also work but outer loop will repeat one time more than needed.
 
        # Last i elements are already in place
        for j in range(0, n-i-1):
 
            # traverse the array from 0 to n-i-1
            # Swap if the element found is greater
            # than the next element
            if arr[j] > arr[j + 1] :
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

def quicksort(nums):
   if len(nums) <= 1:
       return nums
   else:
       q = random.choice(nums)
       s_nums = []
       m_nums = []
       e_nums = []
       for n in nums:
           if n < q:
               s_nums.append(n)
           elif n > q:
               m_nums.append(n)
           else:
               e_nums.append(n)
       return quicksort(s_nums) + e_nums + quicksort(m_nums)


# Python3 program to perform basic timSort
MIN_MERGE = 32

def calcMinRun(n):
	"""Returns the minimum length of a
	run from 23 - 64 so that
	the len(array)/minrun is less than or
	equal to a power of 2.

	e.g. 1=>1, ..., 63=>63, 64=>32, 65=>33,
	..., 127=>64, 128=>32, ...
	"""
	r = 0
	while n >= MIN_MERGE:
		r |= n & 1
		n >>= 1
	return n + r


# This function sorts array from left index to
# to right index which is of size atmost RUN
def insertionSort(arr, left, right):
	for i in range(left + 1, right + 1):
		j = i
		while j > left and arr[j] < arr[j - 1]:
			arr[j], arr[j - 1] = arr[j - 1], arr[j]
			j -= 1


# Merge function merges the sorted runs
def merge(arr, l, m, r):
	
	# original array is broken in two parts
	# left and right array
	len1, len2 = m - l + 1, r - m
	left, right = [], []
	for i in range(0, len1):
		left.append(arr[l + i])
	for i in range(0, len2):
		right.append(arr[m + 1 + i])

	i, j, k = 0, 0, l
	
	# after comparing, we merge those two array
	# in larger sub array
	while i < len1 and j < len2:
		if left[i] <= right[j]:
			arr[k] = left[i]
			i += 1

		else:
			arr[k] = right[j]
			j += 1

		k += 1

	# Copy remaining elements of left, if any
	while i < len1:
		arr[k] = left[i]
		k += 1
		i += 1

	# Copy remaining element of right, if any
	while j < len2:
		arr[k] = right[j]
		k += 1
		j += 1


# Iterative Timsort function to sort the
# array[0...n-1] (similar to merge sort)
def timSort(arr):
	n = len(arr)
	minRun = calcMinRun(n)
	
	# Sort individual subarrays of size RUN
	for start in range(0, n, minRun):
		end = min(start + minRun - 1, n - 1)
		insertionSort(arr, start, end)

	# Start merging from size RUN (or 32). It will merge
	# to form size 64, then 128, 256 and so on ....
	size = minRun
	while size < n:
		
		# Pick starting point of left sub array. We
		# are going to merge arr[left..left+size-1]
		# and arr[left+size, left+2*size-1]
		# After every merge, we increase left by 2*size
		for left in range(0, n, 2 * size):

			# Find ending point of left sub array
			# mid+1 is starting point of right sub array
			mid = min(n - 1, left + size - 1)
			right = min((left + 2 * size - 1), (n - 1))

			# Merge sub array arr[left.....mid] &
			# arr[mid+1....right]
			if mid < right:
				merge(arr, left, mid, right)

		size = 2 * size

def matmult(X, Y):
  result = np.zeros((len(a), len(a)))

# iterate through rows of X
  for i in range(len(X)):
   # iterate through columns of Y
    for j in range(len(Y[0])):
       # iterate through rows of Y
        for k in range(len(Y)):
            result[i][j] += X[i][k] * Y[k][j]
  return np.matrix(result)

"""# 1. Constant"""

sum_y = np.zeros(2000)
n = np.arange(1, 2001)
v = np.random.randint(low=1, high=10, size=2000)

for i in range(5):
  y_exp = []
  for el in n:
    start_time = time.time()
    const(v[0:el])
    y_exp.append(time.time() - start_time)
  sum_y += np.array(y_exp)
y_exp_mean = sum_y / 5

y_exp_mean_th = np.full(len(y_exp_mean), np.mean(y_exp_mean))

plt.figure(figsize=(18,9))
plt.plot(n, y_exp_mean, label='experimental')
plt.plot(n, y_exp_mean_th, label='theoretical')
plt.title('Constant computation')
plt.ylabel('Time, s')
plt.xlabel('Vector lenght')
plt.legend()
plt.grid(True)
plt.show()

"""# 2. Sum"""

sum_y = np.zeros(2000)
sum = 0
n = np.arange(1, 2001)
v = np.random.randint(low=1, high=10, size=2000)

for i in range(5):
  y_exp = []
  for el in n:
    start_time = time.time()
    summa(v[0:el])
    y_exp.append(time.time() - start_time)
  sum_y += np.array(y_exp)
y_exp_mean = sum_y / 5

plt.figure(figsize=(18,9))
plt.plot(n, y_exp_mean, label='experimental')
plt.plot(n, y_exp_mean[-1]/(math.pow(n[-1], 1))*np.power(n, 1) + y_exp_mean[1]/2, label='theoretical')
plt.title('Sum computation')
plt.ylabel('Time, s')
plt.xlabel('Vector lenght')
plt.legend()
plt.grid(True)
plt.show()

"""#3. Production"""

sum_y = np.zeros(2000)
v = np.random.randint(low=1, high=10, size=2000)
n = np.arange(1, 2001)

for i in range(5):
  y_exp = []
  for el in n:
    start_time = time.time()
    prod(v[0:el])
    y_exp.append(time.time() - start_time)
  sum_y += np.array(y_exp)
y_exp_mean = sum_y / 5

plt.figure(figsize=(18,9))
plt.plot(n, y_exp_mean, label='experimental')
plt.plot(n, y_exp_mean[-1]/(math.pow(n[-1], 1))*np.power(n, 1) + y_exp_mean[1]/2, label='theoretical')
plt.title('Production computation')
plt.ylabel('Time, s')
plt.xlabel('Vector lenght')
plt.legend()
plt.grid(True)
plt.show()

"""# 4. Polynom

## 4.1 Naive
"""

sum_y = np.zeros(1000)
v = np.random.randint(low=1, high=10, size=1000)
n = np.arange(1, 1001)

for i in range(5):
  y_exp = []
  for el in n:
    start_time = time.time()
    naive(v[0:el], 1.5)
    y_exp.append(time.time() - start_time)
  sum_y += np.array(y_exp)
y_exp_mean = sum_y / 5

plt.figure(figsize=(18,9))
plt.plot(n, y_exp_mean, label='experimental')
plt.plot(n, y_exp_mean[-1]/(math.pow(n[-1], 2))*np.power(n, 2) + y_exp_mean[1]/2, label='theoretical')
plt.title("Naive polynomial computation")
plt.ylabel('Time, s')
plt.xlabel('Vector lenght')
plt.legend()
plt.grid(True)
plt.show()

"""## 4.2 Horner's method"""

sum_y = np.zeros(2000)
v = np.random.randint(low=1, high=10, size=2000)
n = np.arange(1, 2001)

for i in range(5):
  y_exp = []
  for el in n:
    start_time = time.time()
    Horner(v[0:el], 1.5)
    y_exp.append(time.time() - start_time)
  sum_y += np.array(y_exp)
y_exp_mean = sum_y / 5

plt.figure(figsize=(18,9))
plt.plot(n, y_exp_mean, label='experimental')
plt.plot(n, y_exp_mean[-1]/(math.pow(n[-1], 1))*np.power(n, 1) + y_exp_mean[1]/2, label='theoretical')
plt.title("Horner's method polynomial computation")
plt.ylabel('Time, s')
plt.xlabel('Vector lenght')
plt.legend()
plt.grid(True)
plt.show()

"""# 5. Bubble Sort"""

sum_y = np.zeros(1000)
v = np.random.randint(low=1, high=10, size=1000)
n = np.arange(1, 1001)

for i in range(5):
  y_exp = []
  for el in n:
    start_time = time.time()
    bubbleSort(v[0:el])
    y_exp.append(time.time() - start_time)
  sum_y += np.array(y_exp)
y_exp_mean = sum_y / 5

plt.figure(figsize=(18,9))
plt.plot(n, y_exp_mean, label='experimental')
plt.plot(n, y_exp_mean[-1]/(math.pow(n[-1], 2))*np.power(n, 2) + y_exp_mean[1]/2, label='theoretical')
plt.title('Bubble sort computation')
plt.ylabel('Time, s')
plt.xlabel('Vector lenght')
plt.legend()
plt.grid(True)
plt.show()

"""# 6. Quick Sort"""

sum_y = np.zeros(1000)
v = np.random.randint(low=1, high=10, size=1000)
n = np.arange(1, 1001)

for i in range(5):
  y_exp = []
  for el in n:
    start_time = time.time()
    quickSort(v[0:el])
    y_exp.append(time.time() - start_time)
  sum_y += np.array(y_exp)
y_exp_mean = sum_y / 5


plt.figure(figsize=(18,9))
plt.plot(n, y_exp_mean, label='experimental')
plt.plot(n, y_exp_mean[-1]/(n[-1] * np.log(n[-1])) * n * np.log(n) + y_exp_mean[1]/2, label='theoretical')
plt.title('Quick sort computation')
plt.ylabel('Time, s')
plt.xlabel('Vector lenght')
plt.legend()
plt.grid(True)
plt.show()

"""#7. Timsort"""

sum_y = np.zeros(2000)
v = np.random.randint(low=1, high=10, size=2000)
n = np.arange(1, 2001)

for i in range(5):
  y_exp = []
  for el in n:
    start_time = time.time()
    timSort(v[0:el])
    y_exp.append(time.time() - start_time)
  sum_y += np.array(y_exp)
y_exp_mean = sum_y / 5


plt.figure(figsize=(18,9))
plt.plot(n, y_exp_mean, label='experimental')
plt.plot(n, y_exp_mean[-1]/(n[-1] * np.log(n[-1])) * n * np.log(n) + y_exp_mean[1]/2, label='theoretical')
plt.title('Timsort computation')
plt.ylabel('Time, s')
plt.xlabel('Vector lenght')
plt.legend()
plt.grid(True)
plt.show()

"""# II. Matrices"""

sum_y = np.zeros(250)
n = np.arange(1, 251)

for i in range(5):
  y_exp = []
  for el in n:
    start_time = time.time()
    a = np.random.randint(low=1, high=10, size=(el, el))
    b = np.random.randint(low=1, high=10, size=(el, el))
    np.matrix(matmult(a, b))
    y_exp.append(time.time() - start_time)
  sum_y += np.array(y_exp)
y_exp_mean = sum_y / 5


plt.figure(figsize=(18,9))
plt.plot(n, y_exp_mean, label='experimental')
plt.plot(n, y_exp_mean[-1]/(math.pow(n[-1], 3))*np.power(n, 3) + y_exp_mean[1]/2, label='theoretical')
plt.title('Matrix computation')
plt.ylabel('Time, s')
plt.xlabel('Vector lenght')
plt.legend()
plt.grid(True)
plt.show()